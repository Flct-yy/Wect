### 用 State 响应输入
#### 声明式 UI 与命令式 UI 的比较
告诉计算机如何去更新 UI 的编程方式被称为命令式编程  
对于独立系统来说，命令式地控制用户界面的效果也不错，但是当处于更加复杂的系统中时，这会造成管理的困难程度指数级地增长。
* **命令式 UI**：关注“怎么做”，即通过一系列明确的指令和操作来构建和更新界面。开发者需要详细地指定每一步的操作，包括创建元素、设置属性、绑定事件等。
* **声明式 UI**：关注“是什么”，即描述界面的最终状态和期望结果，而不是具体实现过程。开发者只需声明界面元素及其状态之间的关系，框架会自动处理界面的更新和渲染。

1. 定位你的组件中不同的视图状态
2. 确定是什么触发了这些 state 的改变
3. 表示内存中的 state（需要使用 useState）
4. 删除任何不必要的 state 变量
5. 连接事件处理函数去设置 state
- - -
### 选择 State 结构
1. **合并关联的 state** 如果你总是同时更新两个或更多的 state 变量，请考虑将它们合并为一个单独的 state 变量。
2. **避免互相矛盾的 state** 当 state 结构中存在多个相互矛盾或“不一致”的 state 时，你就可能为此会留下隐患。应尽量避免这种情况。
3. **避免冗余的 state** 如果你能在渲染期间从组件的 props 或其现有的 state 变量中计算出一些信息，则不应将这些信息放入该组件的 state 中。
4. **避免重复的 state** 当同一数据在多个 state 变量之间或在多个嵌套对象中重复时，这会很难保持它们同步。应尽可能减少重复。
5. **避免深度嵌套的 state** 深度分层的 state 更新起来不是很方便。如果可能的话，最好以扁平化方式构建 state。

**注:**  
    不要在 state 中镜像 props  
    一个 color state 变量被初始化为 messageColor 的 prop 值。这段代码的问题在于，如果父组件稍后传递不同的 messageColor 值（例如，将其从 'blue' 更改为 'red'），则 color state 变量将不会更新！ state 仅在第一次渲染期间初始化。只有当你 想要 忽略特定 props 属性的所有更新时，将 props “镜像”到 state 才有意义。按照惯例，prop 名称以 initial 或 default 开头，以阐明该 prop 的新值将被忽略
- - -
### 在组件间共享状态
可以将相关 state 从这两个组件上移除，并把 state 放到它们的公共父级，再通过 props 将 state 传递给这两个组件。这被称为 **“状态提升”**  
通常我们把包含“不受控制”状态的组件称为 **“非受控组件”**  
当组件中的重要信息是由 props 而不是其自身状态驱动时，就可以认为该组件是 **“受控组件”**。这就允许父组件完全指定其行为。  
对于每个独特的状态，都应该存在且只存在于一个指定的组件中作为 state。这一原则也被称为拥有 **“可信单一数据源”**
- - -
### 对 state 进行保留和重置
#### 状态与渲染树中的位置相关 
React 会为 UI 中的组件结构构建 渲染树。  
当向一个组件添加状态时，那么可能会认为状态“存在”在组件内。但实际上，状态是由 React 保存的。React 通过组件在渲染树中的位置将它保存的每个状态与正确的组件关联起来。  
只要一个组件还被渲染在 UI 树的相同位置，React 就会保留它的 state。 如果它被移除，或者一个不同的组件被渲染在相同的位置，那么 React 就会丢掉它的 state。
#### 相同位置的相同组件会使得 state 被保留下来
位于相同位置的相同组件，所以对 React 来说，它是同一个组件  
记住 对 React 来说重要的是组件在 UI 树中的位置,而不是在 JSX 中的位置！ 
#### 相同位置的不同组件会使 state 重置
当你在相同位置渲染不同的组件时，组件的整个子树都会被重置。  
一般来说，如果你想在重新渲染时保留 state，几次渲染中的树形结构就应该相互“匹配”。结构不同就会导致 state 的销毁，因为 React 会在将一个组件从树中移除时销毁它的 state。
#### 在相同位置重置 state
有两个方法可以在它们相互切换时重置 state：
1. 将组件渲染在不同的位置
2. 使用 key 赋予每个组件一个明确的身份
##### 方法一：将组件渲染在不同的位置
这个解决方案在你只有少数几个独立的组件渲染在相同的位置时会很方便。这个例子中只有 2 个组件，所以在 JSX 里将它们分开进行渲染并不麻烦。
##### 方法二：使用 key 来重置 state
key 不只可以用于列表,也可以使用 key 来让 React 区分任何组件。默认情况下，React 使用父组件内部的顺序（“第一个计数器”、“第二个计数器”）来区分组件。但是 key 可以让你告诉 React 这不仅仅是 第一个 或者 第二个 计数器，而且还是一个特定的计数器  
请记住 key 不是全局唯一的。它们只能指定 父组件内部 的顺序。
- - -
### 迁移状态逻辑至 Reducer 中
将组件的所有状态更新逻辑整合到一个外部函数中，这个函数叫作 reducer
#### 使用 reducer 整合状态逻辑
Reducer 是处理状态的另一种方式。你可以通过三个步骤将 useState 迁移到 useReducer：
1. 将设置状态的逻辑 修改 成 dispatch 的一个 action；
2. 编写 一个 reducer 函数；
3. 在你的组件中 使用 reducer。

reducer 函数就是你放置状态逻辑的地方。其接受两个参数，分别为当前 state 和 action 对象，并且返回的是更新后的 state  
useReducer 钩子接受 2 个参数：一个 reducer 函数, 一个初始的 state  

`import { useReducer } from 'react';`  

`const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);`  
**注意点:**
1. reducer 必须是纯粹的。 这一点和 状态更新函数 是相似的，reducer 是在渲染时运行的！（actions 会排队直到下一次渲染)。 这就意味着 reducer 必须纯净，即当输入相同时，输出也是相同的。它们不应该包含异步请求、定时器或者任何副作用（对组件外部有影响的操作）。它们应该以不可变值的方式去更新 对象 和 数组。
2. 每个 action 都描述了一个单一的用户交互，即使它会引发数据的多个变化。 举个例子，如果用户在一个由 reducer 管理的表单（包含五个表单项）中点击了 重置按钮，那么 dispatch 一个 reset_form 的 action 比 dispatch 五个单独的 set_field 的 action 更加合理。如果你在一个 reducer 中打印了所有的 action 日志，那么这个日志应该是很清晰的，它能让你以某种步骤复现已发生的交互或响应。这对代码调试很有帮助！
- - -
### 使用 Context 深层传递参数
Context 允许父组件向其下层无论多深的任何组件提供信息，而无需通过 props 显式传递。
#### Context：传递 props 的另一种方法
1. 创建 一个 context。  
    通过 export const MyContext = createContext(defaultValue) 创建并导出 context。
2. 在需要数据的组件内 使用 刚刚创建的 context。  
    在无论层级多深的任何子组件中，把 context 传递给 useContext(MyContext) Hook 来读取它。
3. 在指定数据的组件中 提供 这个 context。  
    在父组件中把 children 包在 <MyContext value={...}> 中来提供 context。

useContext 是一个 Hook。和 useState 以及 useReducer一样，你只能在 React 组件中（不是循环或者条件里）立即调用 Hook。
- - -
### 使用 Reducer 和 Context 拓展你的应用
Reducer 可以整合组件的状态更新逻辑。Context 可以将信息深入传递给其他组件。你可以组合使用它们来共同管理一个复杂页面的状态。
#### 结合使用 reducer 和 context
下面将介绍如何结合使用 reducer 和 context：
1. 创建 context。
2. 将 state 和 dispatch 放入 context。
3. 在组件树的任何地方 使用 context。
- - -
### 脱围机制（Escape Hatches）
#### 使用 ref 引用值
与 state 一样，ref 在重新渲染之间由 React 保留。但是，设置 state 会重新渲染组件，而更改 ref 不会！你可以通过 ref.current 属性访问该 ref 的当前值。
#### 使用 ref 操作 DOM
React 没有内置的方法来执行此类操作，所以需要一个指向 DOM 节点的 ref 来实现
### 使用 Effect 进行同步
与处理特定事件的事件处理程序不同，Effect 在渲染后运行一些代码。使用它将组件与 React 之外的系统同步。
有两种常见的不必使用 Effect 的情况：
1. 不必为了渲染而使用 Effect 来转换数据。
2. 不必使用 Effect 来处理用户事件。

Effect 只能做两件事：开始同步某些东西，然后停止同步它。如果 Effect 依赖于随时间变化的 props 和 state，这个循环可能会发生多次。
- - -
### 使用 ref 引用值
#### 给你的组件添加 ref
通过从 React 导入 useRef Hook 来为你的组件添加一个 ref`import { useRef } from 'react';`  
调用 useRef Hook 并传入你想要引用的初始值作为唯一参数`const ref = useRef(0);`  
用 ref.current 属性访问该 ref 的当前值。这个值是有意被设置为可变的，意味着你既可以读取它也可以写入它。  
组件不会在每次递增时重新渲染。 与 state 一样，React 会在每次重新渲染之间保留 ref。但是，设置 state 会重新渲染组件，更改 ref 不会！
|ref|state|
|---|---|
|useRef(initialValue)返回 { current: initialValue }	|useState(initialValue) 返回 state 变量的当前值和一个 state 设置函数 ( [value, setValue])|
|更改时不会触发重新渲染|	更改时触发重新渲染。|
|可变 —— 你可以在渲染过程之外修改和更新 current 的值。|	“不可变” —— 你必须使用 state 设置函数来修改 state 变量，从而排队重新渲染。|
|你不应在渲染期间读取（或写入） current 值。|	你可以随时读取 state。但是，每次渲染都有自己不变的 state 快照。|
#### 何时使用 ref
如果你的组件需要存储一些值，但不影响渲染逻辑，请选择 ref。
* 存储 timeout ID
* 存储和操作 DOM 元素，我们将在 下一页 中介绍
* 存储不需要被用来计算 JSX 的其他对象。
- - -
### 使用 ref 操作 DOM
将 ref 作为 ref 属性值传递给想要获取的 DOM 节点的 JSX 标签   `<div ref={myRef}>`  React 为这个 `<div>` 创建一个 DOM 节点时，React 会把对该节点的引用放入 myRef.current。然后，你可以从 事件处理器 访问此 DOM 节点，并使用在其上定义的内置浏览器 API。  
Hook 只能在组件的顶层被调用。不能在循环语句、条件语句或 map() 函数中调用 useRef。
#### 访问另一个组件的 DOM 节点
你可以 像其它 prop 一样 将 ref 从父组件传递给子组件。    可以用 useImperativeHandle 限制暴露的功能。
#### React 何时添加 refs 
在 React 中，每次更新都分为 两个阶段：
* 在 渲染 阶段， React 调用你的组件来确定屏幕上应该显示什么。
* 在 提交 阶段， React 把变更应用于 DOM。
- - -
### 使用 Effect 进行同步
Effect 允许你指定由渲染自身，而不是特定事件引起的副作用。useEffect 会“延迟”一段代码的运行，直到渲染结果反映在页面上。  
要编写一个 Effect, 请遵循以下三个步骤：
1. 声明 Effect。通常 Effect 会在每次 提交 后运行。
2. 指定 Effect 依赖。大多数 Effect 应该按需运行，而不是在每次渲染后都运行。例如，淡入动画应该只在组件出现时触发。连接和断开服务器的操作只应在组件出现和消失时，或者切换聊天室时执行。你将通过指定 依赖项 来学习如何控制这一点。 通过在调用 useEffect 时指定一个 依赖数组 作为第二个参数，你可以让 React 跳过不必要地重新运行 Effect。[...]数组中如果有依赖项变化,才会去执行Effect。如果数组为 空,则只会在组件首次出现时运行
3. 必要时添加清理操作。一些 Effect 需要指定如何停止、撤销，或者清除它们所执行的操作。例如，“连接”需要“断开”，“订阅”需要“退订”，而“获取数据”需要“取消”或者“忽略”。你将学习如何通过返回一个 清理函数 来实现这些。在 Effect 中返回一个 清理（cleanup）函数,React 会在每次 Effect 重新运行之前调用清理函数，并在组件卸载（被移除）时最后一次调用清理函数。
- - -
### 你可能不需要 Effect
有两种不必使用 Effect 的常见情况：
* 你不必使用 Effect 来转换渲染所需的数据。例如，你想在展示一个列表前先做筛选。你的直觉可能是写一个当列表变化时更新 state 变量的 Effect。然而，这是低效的。当你更新这个 state 时，React 首先会调用你的组件函数来计算应该显示在屏幕上的内容。然后 React 会把这些变化“提交”到 DOM 中来更新屏幕。然后 React 会执行你的 Effect。如果你的 Effect 也立即更新了这个 state，就会重新执行整个流程。为了避免不必要的渲染流程，应在你的组件顶层转换数据。这些代码会在你的 props 或 state 变化时自动重新执行。
* 你不必使用 Effect 来处理用户事件。例如，你想在用户购买一个产品时发送一个 /api/buy 的 POST 请求并展示一个提示。在这个购买按钮的点击事件处理函数中，你确切地知道会发生什么。但是当一个 Effect 运行时，你却不知道用户做了什么（例如，点击了哪个按钮）。这就是为什么你通常应该在相应的事件处理函数中处理用户事件。  
**摘要**
* 如果你可以在渲染期间计算某些内容，则不需要使用 Effect。
* 想要缓存昂贵的计算，请使用 useMemo 而不是 useEffect。
* 想要重置整个组件树的 state，请传入不同的 key。
* 想要在 prop 变化时重置某些特定的 state，请在渲染期间处理。
* 组件 显示 时就需要执行的代码应该放在 Effect 中，否则应该放在事件处理函数中。
* 如果你需要更新多个组件的 state，最好在单个事件处理函数中处理。
* 当你尝试在不同组件中同步 state 变量时，请考虑状态提升。
* 你可以使用 Effect 获取数据，但你需要实现清除逻辑以避免竞态条件。
- - -
### 响应式 Effect 的生命周期
每个 React 组件都经历相同的生命周期：
* 当组件被添加到屏幕上时，它会进行组件的 挂载。
* 当组件接收到新的 props 或 state 时，通常是作为对交互的响应，它会进行组件的 更新。
* 当组件从屏幕上移除时，它会进行组件的 卸载。

Effect 是一段响应式的代码块。它们在读取的值发生变化时重新进行同步。与事件处理程序不同，事件处理程序只在每次交互时运行一次，而 Effect 则在需要进行同步时运行。  
不能“选择”依赖项。依赖项必须包括 Effect 中读取的每个 响应式值。代码检查工具会强制执行此规则。

* 检查 Effect 是否表示了独立的同步过程。如果 Effect 没有进行任何同步操作，可能是不必要的。如果它同时进行了几个独立的同步操作，将其拆分为多个 Effect。
* 如果想读取 props 或 state 的最新值，但又不想对其做出反应并重新同步 Effect，可以将 Effect 拆分为具有反应性的部分（保留在 Effect 中）和非反应性的部分（提取为名为 “Effect Event” 的内容）。阅读关于将事件与 Effect 分离的内容。
* 避免将对象和函数作为依赖项。如果在渲染过程中创建对象和函数，然后在 Effect 中读取它们，它们将在每次渲染时都不同。这将导致 Effect 每次都重新同步。阅读有关从 Effect 中删除不必要依赖项的更多内容。
- - -
### 将事件从 Effect 中分开
你需要一个将这个非响应式逻辑和周围响应式 Effect 隔离开来的方法。 `useEffectEvent` 这个特殊的 Hook 从 Effect 中提取非响应式逻辑, useEffectEvent 的设计目的就是捕获最新状态，而无需将其声明为依赖项。  
##### 摘要
* 事件处理函数在响应特定交互时运行。
* Effect 在需要同步的时候运行。
* 事件处理函数内部的逻辑是非响应式的。
* Effect 内部的逻辑是响应式的。
* 你可以将非响应式逻辑从 Effect 移到 Effect Event 中。
* 只在 Effect 内部调用 Effect Event。
* 不要将 Effect Event 传给其他组件或者 Hook。
- - -
### 移除 Effect 依赖
* 依赖应始终与代码匹配。
* 当你对依赖不满意时，你需要编辑的是代码。
* 抑制 linter 会导致非常混乱的错误，你应该始终避免它。
* 要移除依赖，你需要向 linter “证明”它不是必需的。
* 如果某些代码是为了响应特定交互，请将该代码移至事件处理的地方。
* 如果 Effect 的不同部分因不同原因需要重新运行，请将其拆分为多个 Effect。
* 如果你想根据以前的状态更新一些状态，传递一个更新函数。
* 如果你想读取最新值而不“反应”它，请从 Effect 中提取出一个 Effect Event。
* 在 JavaScript 中，如果对象和函数是在不同时间创建的，则它们被认为是不同的。
* 尽量避免对象和函数依赖。将它们移到组件外或 Effect 内。
- - -
### 使用自定义 Hook 复用逻辑
1. React 组件名称必须以大写字母开头，比如 StatusBar 和 SaveButton。React 组件还需要返回一些 React 能够显示的内容，比如一段 JSX。
2. Hook 的名称必须以 use 开头，然后紧跟一个大写字母，就像内置的 useState 或者本文早前的自定义 useOnlineStatus 一样。Hook 可以返回任意值。  
3. 自定义 Hook 共享的只是状态逻辑而不是状态本身。对 Hook 的每个调用完全独立于对同一个 Hook 的其他调用。
* 自定义 Hook 让你可以在组件间共享逻辑。
* 自定义 Hook 命名必须以 use 开头，后面跟一个大写字母。
* 自定义 Hook 共享的只是状态逻辑，不是状态本身。
* 你可以将响应值从一个 Hook 传到另一个，并且他们会保持最新。
* 每次组件重新渲染时，所有的 Hook 会重新运行。
* 自定义 Hook 的代码应该和组件代码一样保持纯粹。
* 把自定义 Hook 收到的事件处理函数包裹到 Effect Event。
* 不要创建像 useMount 这样的自定义 Hook。保持目标具体化。
* 如何以及在哪里选择代码边界取决于你。