### 响应事件
添加一个事件处理函数，你需要先定义一个函数，然后 将其作为 prop 传入 合适的 JSX 标签。
事件处理函数有如下特点:
* 通常在你的组件 内部 定义。
* 名称以 handle 开头，后跟事件名称

传递给事件处理函数的函数应直接传递，而非调用  
定义内联事件处理函数，请将其包装在匿名函数中
事件处理函数声明于组件内部，因此它们可以直接访问组件的 props
#### 命名事件处理函数 prop 
按照惯例，事件处理函数 props 应该以 on 开头，后跟一个大写字母
#### 事件传播 
事件处理函数还将捕获任何来自子组件的事件。通常，我们会说事件会沿着树向上“冒泡”或“传播”：它从事件发生的地方开始，然后沿着树向上传播
#### 阻止传播 
事件处理函数接收一个 事件对象 作为唯一的参数。按照惯例，它通常被称为 e ，代表 “event”（事件）  
这个事件对象还允许你阻止传播。如果你想阻止一个事件到达父组件，你需要像下面 Button 组件那样调用 `e.stopPropagation()`
#### 阻止默认行为
某些浏览器事件具有与事件相关联的默认行为,可以调用事件对象中的 e.preventDefault() 来阻止这种情况发生
* `e.stopPropagation()` 阻止触发绑定在外层标签上的事件处理函数。
* `e.preventDefault()` 阻止少数事件的默认浏览器行为。
- - -
### State：组件的记忆
useState Hook 提供了这两个功能：
1. State 变量 用于保存渲染间的数据。
2. State setter 函数 更新变量并触发 React 再次渲染组件。

要添加 state 变量，先从文件顶部的 React 中导入 useState：  
`import { useState } from 'react';`  
`const [index, setIndex] = useState(0);`  
index 是一个 state 变量，setIndex 是对应的 setter 函数。
这里的 [ 和 ] 语法称为**数组解构**，它允许你从数组中读取值。 useState 返回的数组总是正好有两项。
#### Hook
useState 以及任何其他以“use”开头的函数都被称为 Hook  
Hook 是特殊的函数，只在 React 渲染时有效  
Hooks ——以 use 开头的函数——只能在组件或自定义 Hook 的最顶层调用
#### 剖析 useState
惯例是将这对返回值命名为 const [thing, setThing]  
useState 的唯一参数是 state 变量的初始值  
每次你的组件渲染时，useState 都会给你一个包含两个值的数组：

1. state 变量 (index) 会保存上次渲染的值。
2. state setter 函数 (setIndex) 可以更新 state 变量并触发 React 重新渲染组件。

在一个组件中可以拥有任意多种类型的 state 变量  
在 React 内部，为每个组件保存了一个数组，其中每一项都是一个 state 对。它维护当前 state 对的索引值，在渲染之前将其设置为 “0”。每次调用 useState 时，React 都会为你提供一个 state 对并增加索引值
#### State 是隔离且私有的
如果你渲染同一个组件两次，每个副本都会有完全隔离的 state！改变其中一个不会影响另一个  
state 完全私有于声明它的组件, 父组件无法更改它。这使你可以向任何组件添加或删除 state，而不会影响其他组件  
如果想要两个画廊保持其 states 同步怎么办？在 React 中执行此操作的正确方法是从子组件中删除 state 并将其添加到离它们最近的共享父组件中
- - -
### 渲染和提交
#### 步骤 1: 触发一次渲染 
有两种原因会导致组件的渲染:
* 组件的 初次渲染。
* 组件（或者其祖先之一）的 状态发生了改变。

**初次渲染**
当应用启动时，会触发初次渲染。框架和沙箱有时会隐藏这部分代码，但它是通过调用 createRoot 方法并传入目标 DOM 节点，然后用你的组件调用 render 函数完成的  
**状态更新时重新渲染**
一旦组件被初次渲染，你就可以通过使用 set 函数 更新其状态来触发之后的渲染。更新组件的状态会自动将一次渲染送入队列。
#### 步骤 2: React 渲染你的组件 
在你触发渲染后，React 会调用你的组件来确定要在屏幕上显示的内容。“渲染中” 即 React 在调用你的组件。
* 在进行初次渲染时, React 会调用根组件。
* 对于后续的渲染, React 会调用内部状态更新触发了渲染的函数组件。

渲染必须始终是一次 纯计算:
* 输入相同，输出相同。 给定相同的输入，组件应始终返回相同的 JSX。
* 只做它自己的事情。 它不应更改任何存在于渲染之前的对象或变量。

否则，随着代码库复杂性的增加，你可能会遇到令人困惑的错误和不可预测的行为。在 “严格模式” 下开发时，React 会调用每个组件的函数两次，这可以帮助发现由不纯函数引起的错误。
#### 步骤 3: React 把更改提交到 DOM 上
在渲染（调用）你的组件之后，React 将会修改 DOM。
* 对于初次渲染，React 会使用 appendChild() DOM API 将其创建的所有 DOM 节点放在屏幕上。
* 对于重渲染，React 将应用最少的必要操作（在渲染时计算！），以使得 DOM 与最新的渲染输出相互匹配。

React 仅在渲染之间存在差异时才会更改 DOM 节点。
- - -
### state 如同一张快照
当 React 重新渲染一个组件时：
* React 会再次调用你的函数
* 函数会返回新的 JSX 快照
* React 会更新界面以匹配返回的快照

你的组件会在其 JSX 中返回一张包含一整套新的 props 和事件处理函数的 UI 快照 ，其中所有的值都是 根据那一次渲染中 state 的值 被计算出来的  
一个 state 变量的值永远不会在一次渲染的内部发生变化， 即使其事件处理函数的代码是异步的  
React 会使 state 的值始终“固定”在一次渲染的各个事件处理函数内部。你无需担心代码运行时 state 是否发生了变化。
- - -
### 把一系列 state 更新加入队列
React 会等到事件处理函数中的 所有 代码都运行完毕再处理你的 state 更新。 这就是重新渲染只会发生在所有这些 setNumber() 调用 之后 的原因。  
只有在你的事件处理函数及其中任何代码执行完成 之后，UI 才会更新。这种特性也就是**批处理**  
React 不会跨 多个 需要刻意触发的事件（如点击）进行批处理——每次点击都是单独处理的。
#### 在下次渲染前多次更新同一个 state 
像 `setNumber(n => n + 1)` 这样传入一个根据队列中的前一个 state 计算下一个 state 的 函数，而不是像 `setNumber(number + 1)` 这样传入 下一个 state 值。这是一种告诉 React “用 state 值做某事”而不是仅仅替换它的方法。  
在这里，n => n + 1 被称为 更新函数`(更新函数必须是 纯函数 并且只 返回 结果)`。当你将它传递给一个 state 设置函数时：
1. React 会将此函数加入队列，以便在事件处理函数中的所有其他代码运行后进行处理。
2. 在下一次渲染期间，React 会遍历队列并给你更新之后的最终 state。

总而言之，以下是你可以考虑传递给 `setNumber state` 设置函数的内容：
* `一个更新函数`（例如：n => n + 1）会被添加到队列中。
* `任何其他的值`（例如：数字 5）会导致“替换为 5”被添加到队列中，已经在队列中的内容会被忽略。
- - -
### 更新 state 中的对象
state 中可以保存任意类型的 JavaScript 值，包括对象。但是，你不应该直接修改存放在 React state 中的对象。相反，当你想要更新一个对象时，你需要创建一个新的对象（或者将其拷贝一份），然后将 state 更新为此对象。
#### 什么是 mutation？
Mutation 是指对数据结构进行的可观察更改。在 JavaScript 中，Mutation 通常指的是直接修改对象或数组的内容，例如更改对象的属性值或数组的元素。与 Mutation 相对的是 Immutability，即不可变性，指的是不修改数据结构的状态
#### 将 state 视为只读的
你应该 把所有存放在 state 中的 JavaScript 对象都视为只读的。为了真正地 触发一次重新渲染，你需要创建一个新对象并把它传递给 state 的设置函数  
通过使用 setPosition，你在告诉 React：
* 使用这个新的对象替换 position 的值
* 然后再次渲染这个组件
#### 使用展开语法复制对象
... 展开语法本质是是“浅拷贝”——它只会复制一层。这使得它的执行速度很快，但是也意味着当你想要更新一个嵌套属性时，你必须得多次使用展开语法。
#### 更新一个嵌套对象
React 中，你需要将 state 视为不可变的！为了修改 嵌套对象 的值，创建两个对象,并使其嵌套
#### 使用 Immer 编写简洁的更新逻辑
尝试使用 Immer:
1. 运行 `npm install use-immer` 添加 `Immer` 依赖
2. 用 `import { useImmer } from 'use-immer'` 替换掉 `import { useState } from 'react'`
3. `const [something, updatesomething] = useImmer(...)`(`updatePerson(draft=> {...})`
- - -
### 更新 state 中的数组
不应该使用会直接修改原始数组的方法，例如 push() 和 pop()。相反，每次要更新一个数组时，你需要把一个新的数组传入 state 的 setting 方法中。为此，你可以通过使用像 filter() 和 map() 这样不会直接修改原始值的方法，从原始数组生成一个新的数组。然后你就可以将 state 设置为这个新生成的数组。
|        |	避免使用 (会改变原始数组)	|推荐使用 (会返回一个新数组）|
|---|---|---|
|添加元素|	push，unshift	            |concat，[...arr] 展开语法（例子）|
|删除元素|	pop，shift，splice	      |filter，slice（例子）|
|替换元素|	splice，arr[i] = ... 赋值 |map（例子）|
|排序    |	reverse，sort	            |先将数组复制一份（例子）|

或者，你可以使用 Immer ，这样你便可以使用表格中的所有方法了。  
**注**:
* slice 让你可以拷贝数组或是数组的一部分。
* splice 会直接修改 原始数组（插入或者删除元素）。

数组展开运算符还允许你把新添加的元素放在原始的 ...artists 之前,展开操作就可以完成 push() 和 unshift() 的工作，将新元素添加到数组的末尾和开头

**向数组中插入元素**

有时，你也许想向数组特定位置插入一个元素，这个位置既不在数组开头，也不在末尾。为此，你可以将数组展开运算符 ... 和 slice() 方法一起使用。slice() 方法让你从数组中切出“一片”。为了将元素插入数组，你需要先展开原数组在插入点之前的切片，然后插入新元素，最后展开原数组中剩下的部分。

**更新数组内部的对象**  
当你更新一个嵌套的 state 时，你需要从想要更新的地方创建拷贝值，一直这样，直到顶层。   
通常来讲，你应该只直接修改你刚刚创建的对象。如果你正在插入一个新的 东西，你可以修改它，但是如果你想要改变的是 state 中已经存在的东西，你就需要先拷贝一份了。