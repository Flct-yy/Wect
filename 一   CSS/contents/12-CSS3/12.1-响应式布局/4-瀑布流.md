# 瀑布流布局
一种流行的布局方式，其特点是元素宽度固定，高度不统一，并像瀑布一样向下流动排列。

## 一、CSS Grid + grid-auto-flow: dense

CSS Grid 布局提供了一种更加灵活的布局方式，可以实现更复杂的布局。

```css
.container {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); 
  grid-auto-rows: 10px;   /* 行高单位 */
  grid-auto-flow: dense;  /* 紧密填充 */
  gap: 10px;
}

.item {
  grid-row-end: span 20;  /* 按内容高度设置跨度 */
}
```

## 二、CSS Masonry（实验性：grid-template-rows: masonry）
未来标准，Firefox 已经支持，Chrome 也在实验阶段。  
可以真正做到 原生 CSS 瀑布流。

```css
.container {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
  grid-template-rows: masonry; /* Masonry 布局 */
  gap: 10px;
}
```

## 三、JS + CSS 实现瀑布流
最常见的 生产环境方案，用 JS 计算每个 item 放在哪一列。

常用库：

* Masonry.js
* Isotope
* 或者自己用 JS 实现 “最短列” 算法。

思路：

* 初始化列高度数组
* 遍历元素，找到高度最小的列，把元素放进去
* 更新该列高度

```css
.masonry {
  position: relative;
  width: 100%;
  margin: 0 auto;
}

.item {
  position: absolute; /* 关键：通过 JS 定位 */
  width: 200px;       /* 单个 item 的宽度 */
  margin: 0; 
  box-sizing: border-box;
  border-radius: 8px;
  background: #bcd5fd;
  padding: 10px;
}
```

```js
// 瀑布流布局函数
// containerId: 容器 ID
// colWidth: 单个 item 宽度
// gap: 列间距
function masonryLayout(containerId, colWidth, gap) {
  const container = document.getElementById(containerId);
  const items = container.getElementsByClassName('item');

  // 容器宽度
  const containerWidth = container.clientWidth;
  // 计算列数
  const colCount = Math.floor(containerWidth / (colWidth + gap));
  // 列高度数组
  const colHeights = new Array(colCount).fill(0);

  for (let i = 0; i < items.length; i++) {
    const item = items[i];

    // 找到最短的列 返回设置的索引
    const minCol = colHeights.indexOf(Math.min(...colHeights));
    // 计算 item 位置
    // x: 列左侧距离，y: 列顶部距离
    const x = minCol * (colWidth + gap);
    const y = colHeights[minCol];

    // 设置 item 位置
    item.style.width = colWidth + "px";
    item.style.left = x + "px";
    item.style.top = y + "px";

    // 更新该列的高度
    colHeights[minCol] += item.offsetHeight + gap;
  }

  // 设置容器高度
  container.style.height = Math.max(...colHeights) + "px";
}

// 初始化 & 窗口缩放时重新计算
window.onload = () => masonryLayout("masonry", 200, 16);
window.onresize = () => masonryLayout("masonry", 200, 16);

```

