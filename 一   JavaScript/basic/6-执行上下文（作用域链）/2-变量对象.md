# 变量对象

变量对象 是与执行上下文相关的 `数据作用域`，存储了上下文中定义的 `变量` 和 `函数声明`。

存储上下文中定义的：
* 变量（var 声明）
* 函数声明
* 函数参数（函数上下文中）

变量对象有全局上下文中变量对象和函数上下文下的变量对象之分。

## 全局上下文的变量对象(GO)

全局上下文的`变量对象(VO)`就是`全局对象(GO)`，比如 web 浏览器中，全局对象就有 window 属性指向自身，window 对象。全局对象是由 Object 构造函数实例化的一个对象。预定义一大堆函数和属性。作为全局变量的宿主。

全局上下文的变量对象就是全局对象，web 浏览器是 window、self 或者 frames ，node 中是 global， Web Workers 中是 self，不同环境下的统一标准的全局变量是 globalThis。

在松散模式下，可以在函数中返回 this 来获取全局对象，但是在严格模式和模块环境下，this 会返回 undefined。

## 函数上下文的变量对象(AO)

函数上下文中用 `活动对象(Activation Object)` 表示`变量对象(VO)`。活动对象在进入函数上下文时被创建，通过函数的 arguments 属性初始化。分析一个函数上下文的 AO 对象很重要。

活动对象和变量对象其实是一个东西，只是变量对象是规范上的或者说是引擎实现上的，不可在 JavaScript 环境中访问，只有当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，才叫 activation object。

活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。arguments 属性值是 `Arguments 对象`。即，调用函数时，会为其创建一个 Arguments 对象，并自动初始化局部变量 arguments，指代该 Arguments 对象。所有作为参数传入的值都会成为 Arguments 对象的数组元素。

##### 注: 函数提升优先级高于变量提升，且不会被同名变量声明时覆盖，但是会被同名变量赋值后覆盖。


## VO 与 AO
未进入执行阶段之前，变量对象(VO)中的属性都不能访问！但是进入执行阶段之后，变量对象(VO)转变为了活动对象(AO)，里面的属性都能被访问了，然后开始进行执行阶段的操作。它们其实都是同一个对象，只是处于执行上下文的不同生命周期。

`AO = VO + function parameters + arguments`  
AO 实际上是包含了 VO 的。因为除了 VO 之外，AO 还包含函数的 parameters，以及 arguments 这个特殊对象。也就是说 AO 的确是在进入到执行阶段的时候被激活，但是激活的除了 VO 之外，还包括函数执行时传入的参数和 arguments 这个特殊对象。

## 变量对象会包括
* 函数的所有形参 (如果是函数上下文)
  * 由名称和对应值组成的一个变量对象的属性被创建
  * 没有实参，属性值设为 undefined
* 函数声明
  * 由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建
  * 如果变量对象已经存在相同名称的属性，则完全替换这个属性
* 变量声明
  * 由名称和对应值（undefined）组成一个变量对象的属性被创建
  * 如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性