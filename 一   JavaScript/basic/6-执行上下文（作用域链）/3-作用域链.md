# 作用域链

在变量对象中，当查找变量的时候，对象中会先从当前执行上下文中的变量对象中查找变量（当前作用域），如果没有找到，就会从父级（词法层面的父级：书写位置）执行上下文中的变量对象中查找变量（父级作用域），一直到全局上下文的变量对象中，也就是全局对象中（全局作用域）。这样由多个执行上下文的变量对象构成的链叫做 `作用域链`。

作用域链（Scope Chain）是一个非常重要的概念，它决定了如何查找变量，即确定了在何处查找变量的顺序。作用域链是在执行上下文（execution context）被创建时构建的，它由一系列可访问的作用域组成，这些作用域按照特定的顺序链接在一起。 JavaScript 引擎会从当前作用域开始查找该变量，如果当前作用域中没有找到，就会沿着作用域链向上查找，直到全局作用域。如果在全局作用域中仍然没有找到该变量，就会返回 undefined。

<hr>

`函数的作用域在函数定义时就确定了。`  
因为函数有一个内部属性 [[scope]]，当函数创建的时候，就会保存所有父变量对象到其中， [[scope]] 就是所有父变量对象的层级链，但是注意：[[scope]] 并不代表完整的作用域链！

`函数激活`，进入函数上下文，创建 VO、AO 对象后，就会将 AO 添加到作用域链的前端。这时候执行上下文的作用域链，我们命名为 Scope：Scope = [AO].concat([[Scope]])，至此，作用域链创建完毕。



以下面的例子为例，结合着之前讲的变量对象和执行上下文栈，我们来总结一下函数执行上下文中作用域链和变量对象的创建过程：
```javascript
var scope = "global scope";
function checkscope(){
    var scope2 = 'local scope';
    return scope2;
}
checkscope();
```
执行过程如下：

1. checkscope 函数被创建，保存作用域链到 内部属性 [[scope]]
```javascript
checkscope.[[scope]] = [
    globalContext.VO
];
```
2. 执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈
```javascript
ECStack = [
    checkscopeContext,
    globalContext
];
```
3. checkscope 函数并不立刻执行，开始做准备工作，第一步：复制函数 [[scope]] 属性创建作用域链
```javascript
checkscopeContext = {
    Scope: checkscope.[[scope]],
}
```
4. 第二步：用 arguments 创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明
```javascript
checkscopeContext = {
    AO: {
        arguments: {
            length: 0
        },
        scope2: undefined
    }，
    Scope: checkscope.[[scope]],
}
```
5. 第三步：将活动对象压入 checkscope 作用域链顶端
```javascript
checkscopeContext = {
    AO: {
        arguments: {
            length: 0
        },
        scope2: undefined
    },
    Scope: [AO, [[Scope]]]
}
```
6. 准备工作做完，开始执行函数，随着函数的执行，修改 AO 的属性值
```javascript
checkscopeContext = {
    AO: {
        arguments: {
            length: 0
        },
        scope2: 'local scope'
    },
    Scope: [AO, [[Scope]]]
}
```
7. 查找到 scope2 的值，返回后函数执行完毕，函数上下文从执行上下文栈中弹出
```javascript
ECStack = [
    globalContext
];
```


<hr>

# 作用域

作用域是程序中定义变量的区域，它规定了变量和函数的可见性和生命周期。作用域是确定在何处以及如何查找变量的一套规则。

JavaScrip 采用词法作用域(lexical scoping)，也就是静态作用域。

## 两作用域的区别
词法作用域(静态作用域)和动态作用域的区别：

* 词法作用域：因为 JavaScript 采用的是词法作用域，函数的作用域在函数定义的时候就决定了。`函数的作用域基于函数创建的位置。`
* 动态作用域：而与词法作用域相对的是动态作用域，`函数的作用域是在函数调用的时候才决定的。`

在全局作用域中“定义”一个函数的时候，只会记录包含全局作用域的作用域链。只有“执行”该函数的时候，才会复制创建时的作用域，并将当前函数的局部作用域放在作用域链的顶端。 `词法作用域是通过作用域链来实现的。`

动态作用域和静态作用域，规定变量访问权，决定的作用域链的顺序。

<hr>

## 作用域类型
JavaScript 有三种作用域类型：

(1) 全局作用域 (Global Scope)
* 在代码最外层定义的变量
* 在任何地方都可以访问
* 浏览器中属于 window 对象
* Node.js 中属于 global 对象

(2) 函数作用域 (Function Scope)
* 在函数内部定义的变量
* 只能在函数内部访问
* 使用 var 声明的变量具有函数作用域


(3) 块级作用域 (Block Scope - ES6+)
* 使用 {} 包围的代码块
* 使用 let 和 const 声明的变量具有块级作用域
* 适用于 if、for、while 等语句块

(4) 模块作用域 (Module Scope - ES6)
* 每个 ES6 模块有自己的作用域
* 使用 export 导出，import 导入

## 闭包与作用域的理解
JavaScript 是采用词法作用域的，这就意味着 `函数的执行依赖于函数定义的时候所产生（而不是函数调用的时候产生的）的变量作用域。`为了去实现这种词法作用域，JavaScript 函数对象的内部状态不仅包含函数逻辑的代码，除此之外还 `包含当前作用域链的引用`。函数对象可以通过这个 `作用域链` 相互关联起来，如此，函数体内部的变量都可以保存在函数的作用域内，这在计算机的文献中被称之为 `闭包`。所以`闭包是指一个函数能够访问其定义时的作用域中的变量，即使在其定义的作用域已经执行完毕后。这意味着闭包可以让函数“记住”它被创建时的环境，即使它在另一个环境被调用，而这种“记住”正是通过作用域链实现。
`
从技术的角度去讲，所有的 JavaScript 函数都是闭包：他们都是对象，他们都有一个关联到他们的作用域链。绝大多数函数在调用的时候使用的作用域链和他们在定义的时候的作用域链是相同的，但是这并不影响闭包。当 `调用函数的时候闭包所指向的作用域链` 和 定义函数时的作用域链 不是同一个作用域链的时候，闭包 become interesting。这种 interesting 的事情往往发生在这样的情况下： 当一个函数嵌套了另外的一个函数，外部的函数将内部嵌套的这个函数作为对象返回。一大批强大的编程技术都利用了这类嵌套的函数闭包。

在 JavaScript 中，外部函数`无法直接访问`内部函数的变量，这是由于作用域链的单向性决定的。当函数嵌套时，内部函数可以访问外部函数的变量（包括参数、局部变量和外部函数的内部函数的变量），但外部函数不能访问内部函数的变量。这是因为内部函数的作用域链包含了外部函数的作用域，而外部函数的作用域链中并不包含内部函数的作用域。因此，内部函数可以访问外部函数的变量，但外部函数不能访问内部函数的变量。

尽管外部函数不能直接访问内部函数的变量，但可以`通过返回内部函数来创建闭包，从而间接访问这些变量`。闭包使得内部函数即使在其外部函数执行完毕后，仍然可以访问外部函数的作用域中的变量。使内部函数返回一个函数形成闭包，通过闭包，外部函数可操作内部变量。这样做的话一是可以读取函数内部的变量，二是可以让这些变量的值始终保存在内存中。


`从 v8 角度看函数的作用域`：这是 v8 编译的结果，v8 有惰性编译，在开始编译时遇到函数会保存其为函数对象，在编译顶层代码为 ast 与字节码再去执行。这是为了优化执行速度，因为大部分函数在执行顶层代码时是不会执行的。但是有个问题，函数的执行上下文栈中的变量都是存在与栈中的，而 js 的函数有闭包性质。如果外层的函数执行结束它的作用域也会被销毁，那栈中的变量同时也被销毁。这就有了预解析。 顺序就是预解析 -> 解析 -> 编译执行。 预解析也只查看函数的语法与是否引用外部变量。

(deepseek)