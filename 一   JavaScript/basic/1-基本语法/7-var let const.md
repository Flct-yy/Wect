# JavaScript 变量声明
在 JavaScript 中，可以使用 var、let 和 const 关键字来声明变量。
* var：ES5 引入的变量声明方式，具有函数作用域。
    * 特点：
      * 变量可以重复声明（覆盖原变量）。
      * 变量未赋值时，默认值为 undefined。
      * var 声明的变量会提升(提升到作用域顶部)（Hoisting），但不会初始化。
      * 使用 var 关键字声明的全局作用域变量属于 window 对象 (window.Name 访问变量)
* let：ES6 引入的变量声明方式，具有块级作用域  ( 只在 let 命令所在的代码块内有效 ) 。
    * 使用 let 关键字声明的全局作用域变量不属于 window 对象
* const：ES6 引入的常量声明方式，具有块级作用域，且值不可变。
    * const 关键字在不同作用域，或不同块级作用域中是可以重新声明赋值的

### 块级作用域
大括号 {} 中存在 let，const，function都被认为是块级作用域。这个大括号的范围内相当于一个块级作用域，在执行时会创建私有上下文。注意的是函数也存在变量提升现象，但在块级作用域中的函数，在变量提升阶段，对此函数只声明不定义。块级作用域对 var 不生效。可以访问全局变量。

#### 函数能不能在块级作用域之中声明

ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。

ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。

如果改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6 在附录 B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。

* 允许在块级作用域内声明函数。
* 函数声明类似于 var，即会提升到全局作用域或函数作用域的头部。
* 同时，函数声明还会提升到所在的块级作用域的头部。

注意，上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作 let 处理。根据这三条规则，浏览器的 ES6 环境中，块级作用域内声明的函数，行为类似于 var 声明的变量。考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。

另外，还有一个需要注意的地方。ES6 的块级作用域必须有大括号，如果没有大括号，JavaScript 引擎就认为不存在块级作用域。

### 暂时性死区

在 let 和 const 声明变量之前，只要变量在还没有声明完成前使用，就会报错，都属于该变量的 `暂时性死区`。即，let 和 const 声明的变量不会被提升到作用域顶部，如果在声明之前访问这些变量，会导致报错。let 和 const 声明的变量会放在 TDZ 暂时性死区里面，访问暂时性死区的变量就会报错，且检测报错发生在词法解析(AST词法解析树)阶段，而不是在代码执行阶段。


```
使用 var 关键字重新声明变量可能会带来问题。

var 关键字声明的变量不具备块级作用域的特性，它在 {} 外依然能被访问到。

var x = 10;
// 这里输出 x 为 10
{ 
    var x = 2;
    // 这里输出 x 为 2
}
// 这里输出 x 为 2

let 关键字就可以解决这个问题，因为它只在 let 命令所在的代码块 {} 内有效。

var x = 10;
// 这里输出 x 为 10
{ 
    let x = 2;
    // 这里输出 x 为 2
}
// 这里输出 x 为 10
```

特性|	let	|const
-|-|-
重新赋值|	✅ 允许|	❌ 禁止（声明后不能重新赋值）
必须初始化|	❌ 可不初始化（值默认为 undefined）|	✅ 声明时必须初始化
作用域|	块级作用域（{} 内有效）	|块级作用域（{} 内有效）
重复声明|	❌ 同一作用域禁止重复声明|	❌ 同一作用域禁止重复声明
暂时性死区|	✅ 存在	|✅ 存在
全局属性|	不会成为 window 对象的属性|	不会成为 window 对象的属性

### 常见误区
* ❌ 误区：const 完全不可变
    * 真相：const 只防止重新赋值，对象属性仍可修改
    * 解决方案：用 Object.freeze() 或 Immutable.js 实现真正不可变

* ❌ 误区：let/const 会被提升到块顶部
    * 真相：存在暂时性死区（TDZ），声明前访问会报错

* ❌ 误区：循环中必须用 let
反例：

```javascript
const items = [1, 2, 3];
for (const item of items) { // ✅ 每次迭代创建新绑定
  console.log(item);
}
```

